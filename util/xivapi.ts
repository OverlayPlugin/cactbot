// Helper library for fetching game data from xivapi and
// writing to various resources files.
// See https://xivapi.com

import fs from 'fs';
import path from 'path';

import { exec } from '@actions/exec';
import eslint from 'eslint';
import fetch from 'node-fetch';

const _XIVAPI_URL = 'https://xivapi.com/';

// Max results returned per query
// see https://xivapi.com/docs/Game-Data
const _XIVAPI_RESULTS_LIMIT = 3000;

// We're using some generic typing because the data format
// will depend on the endpoint used by each script.
type XivApiResultData = {
  [key: number]: {
    [column: string]: unknown;
  };
};

type XivApiResult = {
  Results: XivApiResultData;
};

export type OutputFileAttributes = {
  outputFile: string;
  type: string;
  header: string;
  asConst: boolean;
};

const isObject = (obj: unknown): obj is { [key: string]: unknown } =>
  obj !== null && typeof obj === 'object' && !Array.isArray(obj);

const exitError = (msg: string): void => {
  console.error(msg);
  process.exit(1);
};

export class XivApi {
  cactbotPath: string;
  verbose: boolean;

  constructor(cactbotPath: string | null, verbose: boolean) {
    this.verbose = verbose;
    this.cactbotPath = cactbotPath ?? '.';

    if (!fs.existsSync(this.cactbotPath))
      exitError(`Cactbot path does not exist: ${this.cactbotPath}`);

    const cactbotDir = path.resolve(this.cactbotPath).split(path.sep).pop();
    if (cactbotDir !== 'cactbot')
      exitError(`Invalid cactbot path, or script not run from cacbot dir: ${this.cactbotPath}`);

    if (this.verbose)
      console.log(`Using cactbot path: ${this.cactbotPath}`);
  }

  async queryApi(endpoint: string, columns: string[]): Promise<XivApiResultData> {
    if (endpoint === '')
      exitError('Cannot query API: no endpoint specified.');
    if (columns.length === 0)
      exitError(`Cannot query API endpoint ${endpoint}: No columns specified.`);

    const url = `${_XIVAPI_URL}${endpoint}?limit=${_XIVAPI_RESULTS_LIMIT}&columns=${
      columns.join(',')
    }`;

    // TODO: Add some error detection & handling
    const response = await fetch(url);
    const json = (await response.json()) as XivApiResult;

    if (this.verbose)
      console.log(`Xivapi query successful for endpoint: ${endpoint}`);

    return json.Results;
  }

  sortObjByKeys(obj: unknown): unknown {
    if (!isObject(obj) || Array.isArray(obj))
      return obj;

    const out = Object
      .keys(obj)
      .sort()
      .reduce((acc: typeof obj, key) => {
        const nested = obj[key];
        if (isObject(nested))
          acc[key] = this.sortObjByKeys(nested);
        else
          acc[key] = nested;

        return acc;
      }, {});
    return out;
  }

  async writeFile(
    scriptName: string,
    file: OutputFileAttributes,
    data: { [s: string]: unknown },
  ): Promise<void> {
    const fullPath = path.join(this.cactbotPath, file.outputFile);

    let str = JSON.stringify(this.sortObjByKeys(data), null, 2);

    // # make keys integers, remove leading zeroes.
    str = str.replace(/['"]0*([0-9]+)['"]: {/g, '$1: {');

    const fileOutput = `// Auto-generated from ${scriptName}
// DO NOT EDIT THIS FILE DIRECTLY
${file.header !== '' ? `\n` : ''}${file.header}
const data${file.type !== '' ? `: ${file.type}` : ' '} = ${str}${file.asConst ? ' as const' : ''};

export default data;`;

    const linter = new eslint.ESLint({ fix: true });
    const results = await linter.lintText(fileOutput, { filePath: fullPath });

    // There's only one result from lintText, as per documentation.
    const lintResult = results[0];
    if (
      lintResult === undefined ||
      lintResult.errorCount > 0 ||
      lintResult.warningCount > 0
    ) {
      exitError(`Error: eslint failed on output from ${scriptName}.  File not written.`);
      return; // unnecessary, but typescript doesn't know that
    }

    // Overwrite the file, if it already exists.
    const flags = 'w';
    const writer = fs.createWriteStream(fullPath, { flags: flags });
    writer.on('error', (e) => {
      exitError(`Error: Could not write ${file.outputFile}:\n${e.toString()}`);
    });

    writer.write(lintResult.output);

    // run through dprint, so we can see a clean diff before merging
    let _stderr = '';
    const dprintOptions = {
      silent: true, // suppress stdout
      listeners: {
        stderr: (data: Buffer) => {
          _stderr += data.toString();
        },
      },
    };

    await exec(`npx dprint fmt ${fullPath}`, [], dprintOptions);

    if (_stderr.length > 0)
      exitError(`Eroor during dprint:\n${_stderr}`);

    if (this.verbose)
      console.log(`Wrote output file: ${file.outputFile}`);
  }
}
